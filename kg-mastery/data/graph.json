{
    "nodes": [
      {"label": "Data Structures", "description": "Ways of organizing and storing data (lists, trees, graphs, hash tables) that determine what operations are efficient", "concept_type": "concept"},
      {"label": "Algorithms", "description": "Sequences of precise instructions that operate on data to solve computational problems", "concept_type": "concept"},
      {"label": "Abstract Data Types", "description": "High-level data types defined by their operations (list, set, map, priority queue, graph), independent of implementation", "concept_type": "concept"},
      {"label": "Algorithm Design", "description": "Modeling real-world problems formally and iteratively discovering solutions through analogy and refinement", "concept_type": "process"},
      {"label": "Correctness", "description": "An algorithm must produce the right output for every valid input and always terminate", "concept_type": "concept"},
      {"label": "Complexity Analysis", "description": "Measuring how time and memory usage grow with input size, expressed using Big-O notation", "concept_type": "concept"},
      {"label": "Algorithmic Paradigms", "description": "High-level design strategies: divide and conquer, greedy algorithms, and reduction", "concept_type": "concept"},
      {"label": "Sorting & Searching", "description": "Canonical problems: retrieving elements and ordering collections, solved by binary search, merge sort, quicksort, and heapsort", "concept_type": "concept"},
      {"label": "Graph Algorithms", "description": "Algorithms on graph data including traversal (DFS/BFS), minimum spanning trees, and shortest paths", "concept_type": "concept"},
      {"label": "Computability & Theory", "description": "Theoretical limits of what algorithms can compute and how problem difficulty is classified", "concept_type": "concept"}
    ],
    "edges": [
      {"source_label": "Abstract Data Types", "target_label": "Data Structures", "relationship": "is_implemented_by"},
      {"source_label": "Data Structures", "target_label": "Algorithms", "relationship": "is_prerequisite_of"},
      {"source_label": "Algorithms", "target_label": "Algorithm Design", "relationship": "is_prerequisite_of"},
      {"source_label": "Algorithm Design", "target_label": "Correctness", "relationship": "requires"},
      {"source_label": "Algorithm Design", "target_label": "Complexity Analysis", "relationship": "requires"},
      {"source_label": "Algorithms", "target_label": "Algorithmic Paradigms", "relationship": "is_prerequisite_of"},
      {"source_label": "Algorithmic Paradigms", "target_label": "Sorting & Searching", "relationship": "is_prerequisite_of"},
      {"source_label": "Data Structures", "target_label": "Sorting & Searching", "relationship": "enables"},
      {"source_label": "Algorithmic Paradigms", "target_label": "Graph Algorithms", "relationship": "is_prerequisite_of"},
      {"source_label": "Complexity Analysis", "target_label": "Computability & Theory", "relationship": "is_prerequisite_of"}
    ]
  }